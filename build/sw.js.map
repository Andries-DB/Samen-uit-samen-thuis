{"version":3,"sources":["sw.js"],"names":["DEBUG","CACHE_NAME","OFFLINE_URL","self","addEventListener","e","console","log","waitUntil","caches","open","then","cache","add","Request","catch","error","keys","cacheNames","Promise","all","map","cacheName","indexOf","delete","request","url","respondWith","fetch","match"],"mappings":";AAIA,IAAMA,GAAQ,EAGRC,EAAa,KAGbC,EAAc,eAKpBC,KAAKC,iBAAiB,UAAW,SAACC,GAC5BL,GAAOM,QAAQC,IAAI,8BAGvBF,EAAEG,UACAC,OACGC,KAAKT,GACLU,KAAK,SAACC,GACLA,EAAMC,IAAI,IAAIC,QAAQZ,EAAa,CAAEU,MAAO,cAE7CD,KAAK,WACAX,GAAOM,QAAQC,IAAI,kBAAmBL,KAE3Ca,MAAM,SAACC,GACNV,QAAQU,MAAMA,QAStBb,KAAKC,iBAAiB,WAAY,SAACC,GAC7BL,GAAOM,QAAQC,IAAuBN,mBAAAA,OAAAA,EADH,0CAIvCI,EAAEG,UACAC,OAAOQ,OAAON,KAAK,SAACO,GAAeC,OAAAA,QAAQC,IACzCF,EAAWG,IAAI,SAACC,GAEVA,OAAkC,IAAlCA,EAAUC,QAAQtB,GACb,KAEFQ,OAAOe,OAAOF,WAS7BnB,KAAKC,iBAAiB,QAAS,SAACC,GAC1BL,GAAOM,QAAQC,IAAI,2BAA4BF,EAAEoB,QAAQC,KAC7DrB,EAAEsB,YAEAC,MAAMvB,EAAEoB,SAASV,MAAM,SAACC,GAEfP,OADHT,GAAOM,QAAQC,IAAI,gDAAiDS,GACjEP,OAAOoB,MAAM3B","file":"sw.js","sourceRoot":"..\\src","sourcesContent":["/**\n * My Service worker\n */\n// Set the debug state\nconst DEBUG = true;\n\n// The current cache version\nconst CACHE_NAME = 'v4';\n\n// The cache assets\nconst OFFLINE_URL = 'offline.html';\n\n/**\n * When Service Worker is installed\n */\nself.addEventListener('install', (e) => {\n  if (DEBUG) console.log('[Serviceworker] installed.');\n\n  // This caches the files in the installer, on before\n  e.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => {\n        cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));\n      })\n      .then(() => {\n        if (DEBUG) console.log('Cached assets: ', OFFLINE_URL);\n      })\n      .catch((error) => {\n        console.error(error);\n      }),\n  );\n});\n\n/**\n * When Service Worker is active\n * After the install event\n */\nself.addEventListener('activate', (e) => {\n  if (DEBUG) console.log(`[Serviceworker] ${CACHE_NAME} is active & ready to handle fetches!`);\n\n  // Clean the caches\n  e.waitUntil(\n    caches.keys().then((cacheNames) => Promise.all(\n      cacheNames.map((cacheName) => {\n        // Delete the caches that are not the current one.\n        if (cacheName.indexOf(CACHE_NAME) === 0) {\n          return null;\n        }\n        return caches.delete(cacheName);\n      }),\n    )),\n  );\n});\n\n/**\n * When the Fetch event is triggered\n */\nself.addEventListener('fetch', (e) => {\n  if (DEBUG) console.log('[ServiceWorker] Fetching', e.request.url);\n  e.respondWith(\n    // If the fetch fails (because of offlinelessness), return the cached version\n    fetch(e.request).catch((error) => {\n      if (DEBUG) console.log('Fetch failed; returning offline page instead.', error);\n      return caches.match(OFFLINE_URL);\n    }),\n  );\n});\n"]}